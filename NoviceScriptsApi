local api = {}

---Remotes

api.Remotes = {}
function api.Remotes.OnFire(callback) --Sends obj,args
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        local succ,err = pcall(callback,Self,{...})
        if err then 
            error(err)
        end
       return oldinvoke(self, ...)
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        local succ,err = pcall(callback,Self,{...})
        if err then 
            error(err)
        end
       return oldfire(self, ...)
    end)
end
function api.Remotes.RemoteOnFire(callback,remote) -- Sends args,caller
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        if Self == remote then 
             local succ,err = pcall(callback,Self,{...})
             if err then 
                error(err)
            end
        end
       return oldinvoke(self, ...)
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        if Self == remote then 
            local succ,err = pcall(callback,Self,{...})
            if err then 
                error(err)
            end
       end
       return oldfire(self, ...)
    end)

end
function api.Remotes:NullifyRemote(callback,remote,returnObject)
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        if Self == remote then 
             local succ,err = pcall(callback,Self,{...})
             if err then 
                error(err)
            end
        end
       return returnObject
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        if Self == remote then 
            local succ,err = pcall(callback,Self,{...})
            if err then 
                error(err)
            end
       end
       return returnObject
    end)
end

--Http spy
api.HttpRequests = {}
function api.HttpRequests.OnRequest(callback) -- Sends url, path
    local lol
    local old;
    old = hookfunction(game.HttpGet, function(path, url, ...)
        local succ,err = pcall(callback,tostring(url),path)
        if err then 
            error(err)
        end
        return old(a,b,...) 
    end)


end
function api.HttpRequests:Nullify(otherChecks,returnObject)
    local lol
    lol = hookfunc(game.HttpGet,function(path, url, ...)
        local succ,err = pcall(callback,tostring(url),path)
        if err then 
            error(err)
        end
        return lol(path, url, ...)
    end)
end
--Index spy
api.Index = {}
--[[Index info is written like this 
Objects can be nil if you want it to be in general rather than on a specific object

IndexInfo={
    ["WalkSpeed"] = game.Players.LocalPlayer.Character --This path is an object
}
]]
function api.Index.OnIndex(callback,IndexInfo) -- Sends Object,Key (such as "WalkSpeed")
    local OldIndex = nil
    OldIndex = hookmetamethod(game, "__index", function(Self, Key)
        if not checkcaller() then
            local hasKey = false 
            for i,v in pairs(IndexInfo) do 
                if Key == i then
                    if v == nil then 
                        local err,succ = pcall(callback,Self,Key)
                        if err then 
                            error(err)
                        end
                    elseif v == Self then 
                        local err,succ = pcall(callback,Self,Key)
                        if err then 
                            error(err)
                        end
                    end
                end
            end
        end
        return OldIndex(Self, Key)
    end)
end

function api.Index.OnAllIndex(callback) --Sends Object,Key
    local OldIndex = nil
    OldIndex = hookmetamethod(game, "__index", function(Self, Key)
        if not checkcaller() then
            local err,succ = pcall(callback,Self,Key)
            if err then 
                error(err)
            end
        end
        return OldIndex(Self, Key)
    end)
end

--Namecall spy
api.Namecall = {}
--[[otherChecks format:
function(Method,Args)
    if Args[1] == game.Players.LocalPlayer then --Put your custom arguments here
        return true
    end
    return false 
end
]]
function api.Namecall:Nullify(index,returnObject,otherChecks) --index can be "Kick", otherchecks is not mandatory, sends the namecallmethod to otherChecks
    local OldNameCall = nil

    OldNameCall = hookmetamethod(game, "__namecall", function(Self, ...)    
                local Args = {...}
                local NamecallMethod = getnamecallmethod()
            
                if not checkcaller() and NamecallMethod == index then
                    if otherChecks == nil then 
                        return returnObject
                    elseif otherChecks(NamecallMethod,Args) then 
                        return returnObject
                    end
                end
    
        return OldNameCall(Self, ...)
    end)
end

function api.Namecall.OnNamecall(callback) --Sends the method, args ,self (ussualy game)
    local OldNameCall = nil

    OldNameCall = hookmetamethod(game, "__namecall", function(Self, ...)
        local Args = {...}
        local NamecallMethod = getnamecallmethod()
    
        if not checkcaller()  then
            
           local err,suc = pcall(callback,NamecallMethod,Args,Self)
            if err then 
                error(err)
            end
        end
    
        return OldNameCall(Self, ...)
    end)
end 

--Script api 
api.Script = function(Object)
    local lib = {}

    if Object:IsA("LocalScript") or Object:IsA("ModuleScript") then 
    else 
        return nil 
    end

    lib.Args = nil 
    if Object:IsA("ModuleScript") then  
        lib.Args = require(Object)
    else
        lib.Args = getsenv(Object)
    end


    function difference(a, b)
        local diff = {}
        for i,v in pairs(a) do
            if b[i] == v then 
            else 
                diff[tostring(i)] = v
            end
        end 
        return diff
    end
    --NewArgs arguments cna be like this 
    --[[
        {
            ["1"] = true,
            ["test"] = false,
        }
    ]]
    function lib:EditArgs(NewArgs)
        local diff = difference(NewArgs,lib.Args)
        for i,v in pairs(diff) do 
            lib.Args[i] = v
        end
    end
    function lib:Hook(func,callback)
        local oldFunc
        print("hook function args",func,callback)
            print("hook function types",typeof(func),typeof(callback))
        oldFunc = hookfunction(func,function(...)
            if not checkcaller() then 
                local args = {...}
                local suc,err = pcall(callback,Self,...)
                if err then 
                    error(err)
                end
            end
            return oldFunc(...)
        end)
    end
    function lib:Nullify(func,returnObject,otherChecks)
        local oldFunc
        oldFunc = hookfunction(func,function(...)
            if not checkcaller() then
                local Args = {...}
                if otherChecks == nil then 
                    return returnObject
                elseif otherChecks(func,Args) then 
                    return returnObject
                end
            end
            return oldFunc(...)
        end)
    end
    
    function lib:CopyValues()
        setclipboard(table.concat(lib.Args))
    end
    return lib
end

api.reg = {}
function api.reg:FilterType(infoType,callback) -- Sends a table of info, such as info.name; info.func. Also sends the value
    local reg = getreg()
    for i,v in pairs(reg) do 
        if infoType == nil then 
            callback(debug.getinfo(v),v)
        else 
            if type(v) == infoType then 
                callback(debug.getinfo(v),v)
            end
        end
    end
end
function api.reg:FilterName(infoName,callback) -- Sends a table of info, such as info.name; info.func. Also sends the value
    local reg = getreg()
    for i,v in pairs(reg) do 
        local info = debug.getinfo(v)
        if info then
            if info.name == infoName then 
                callback(debug.getinfo(v),v)
            end
        end
    end
end

api.gc = {}

function api.gc:FilterFunctions(constantTable,callback)
    for i,v in pairs(getgc()) do
        if type(v) == "function" and islclosure(v) and not checkcaller(v) then
            local consts = getconstants(v)
            if table.find(consts, "") and table.find(consts, "Filtered") and table.find(consts, "Clan") then
                return v
            end
        end
    end
end
function api.gc:FilterConstants(infoType,constantTable,callback)
    for i,v in pairs(getgc()) do
        if type(v) == infoType and islclosure(v) and not checkcaller(v) then
            local consts = getconstants(v)
            if table.find(consts, "") and table.find(consts, "Filtered") and table.find(consts, "Clan") then
                return v
            end
        end
    end
end
api.functions = {}
function api.functions:Nullify(func,returnObject,otherChecks)
    local oldFunc
    oldFunc = hookfunction(func,function(...)
        if not checkcaller() then
            local Args = {...}
            if otherChecks == nil then 
                return returnObject
            elseif otherChecks(func,Args) then 
                return returnObject
            end
        end
        return oldFunc(...)
    end)
end

function api.customConsole(consoleName)
    local mainLib = {}
    rconsolename(consoleName)
    mainLib.Commands = {
       
    }

    function mainLib:AddPage(pageName)
        local lib = {}
        table.insert(mainLib.Commands,
        {
            ["TableName"] = pageName,
        })
        lib.Table = mainLib.Commands[#mainLib.Commands]
        
        function lib:AddCommand(commandName,argsTable,callback)
            local packedArgs = {
                ["args"] = argsTable,
                ["callback"] = callback
            } -- USE TABLE.UNPACK BTW IF YOU WANT TO MAKE IT SO THAT IT WIL SEND MULTIPLEA RGS
            lib.Table[commandName] = packedArgs
        end

        return lib
    end
    local function getCommands()
        local argsToColor = {
            ["string"] = "@@LIGHT_CYAN@@",
            ["number"] = "@@YELLOW@@",
            ["boolean"] = "@@LIGHT_GREEN@@",
        }
        local keywordColor = {
            ["["] = "@@LIGHT_MAGENTA@@",
            ["*"] = "@@LIGHT_GREEN@@",
            ["]"] = "@@LIGHT_MAGENTA@@",
        }
        local function customPrint(text,newLine)
            for i = 1,string.len(text) do 
                local char = string.sub(text, i, i)
                for index,value in pairs(keywordColor) do 
                    if char == index then 
                        rconsoleprint(value)
                        break
                    end
                end
                rconsoleprint(char)
                rconsoleprint('@@WHITE@@')
            end
            if newLine then
                rconsoleprint('\n')
            end
        end
        local function bulkPrint(textTable,newline)
            for index,value in pairs(textTable) do
                for i,v in pairs(argsToColor) do 
                    if string.find(value,i) then 
                        rconsoleprint(v)
                    end
                end
            
                rconsoleprint(value.." ")
                rconsoleprint('@@WHITE@@')
            end
            if newLine then
                rconsoleprint('\n')
            end
        end
        for index,commands in pairs(mainLib.Commands) do 
            customPrint("[=]:    "..commands["TableName"],true)
            for name,values in pairs(commands) do 
                if name ~= "TableName" then
                    if values.args then
                        rconsoleprint("	["..commands["TableName"] .."]	"..name .." (")
                        --[[
                        local argsTypes = {}
                        local argsNames = {}
                        for i,v in pairs(values[1]) do 
                            local splitArgs = string.split(v,"/")
                            local arg = splitArgs[1]
                            local argType = splitArgs[2]
                            argsTypes[i] = argType
                            argsNames[i] = arg
                        end
                        ]]
                        bulkPrint(values.args)
                        customPrint(")",true)
                    else 
                        rconsoleprint("	["..commands["TableName"] .."]	"..name .."\n")
                    end
                end

            end
        end
    end
    local input = nil 
    input = function()
        local text =  rconsoleinput()
        local splitText = string.split(text," ")
        local pageName = splitText[1]
        local commandName = splitText[2]
        local command = nil 

        for i,v in pairs(mainLib.Commands) do
            if string.lower(v["TableName"]) == string.lower(pageName) then 
                for i2,v2 in pairs(v) do 
                    print(i2,"that was i2")
                    if string.lower(commandName) == string.lower(i2) then 
                        print("v2 is",v2)
                        command = v2
                        break 
                    end
                end
                if command ~= nil then 
                     break 
                end
            end
        end
        if command then else  warn("Command name not found, got",commandName)  input() return end
        local args = {}
        for i,v in pairs(splitText) do 
            if i < 3 then
            print(i,"is lower than 2",v) else
                print(i,"is higher than 2",v) 
                table.insert(args,v)
            end
        end
        if command.args then
            local argsTypes = {}
            for i,v in pairs(command.args) do 
                local splitArgs = string.split(v,"/")
                local argType = splitArgs[2]
                argsTypes[i] = argType
            end
            for i,v in pairs(args) do 
                local argType = argsTypes[i]
                if argType == "boolean" then 
                    local status = false 
                    if v == "on" or v == "true" then 
                        status = true 
                    end
                    args[i] = status 
                elseif argType == "number" then 
                    args[i] = tonumber(v)
                end
            end
            print("ok so",table.unpack(args))
            local err,succ = pcall(command["callback"],table.unpack(args))
            if err then 
                warn(err)
            end
        else 
            print("no args")
            local err,succ = pcall(command["callback"])
            if err then 
                warn(err)
            end
        end
        input()
    end
    table.insert(mainLib.Commands, 
    {
        ["TableName"] = "Console",
        ["commands"] = {
            ["args"] = nil,
            ["callback"] = function() --sends tuple arguments
                getCommands()
            end
        }, 
        ["clear"] = {
            ["args"] = nil,
            ["callback"] = function() --sends tuple arguments
                rconsoleclear()
            end
        },
    })
    function mainLib:Initialize()
        getCommands()
        input()
    end
    return mainLib
end
api.addons = {}
function api.addons:GetPlayer(name)
    for i,v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name:lower():sub(1, #name) == name:lower() or v.	DisplayName:lower():sub(1, #name) == name:lower() then
            return v
        end
    end    
end
function api.addons:getObject(argsTable,name)
    for i,v in pairs(argsTable) do
        if v.Name:lower():sub(1, #name) == name:lower()  then
            return v
        end
    end 
end
function api.addons:getBoolean(stringBool)
    local bool = false
    if stringBool == "true" or stringBool == "on" then
        bool = true
    end
    return bool
end
function api.addons:GetExtraArgs(args)
    local extraArgs = string.split(args,",")
    local hasExtra = false
    if #extraArgs > 1 then
        hasExtra = true
    else 
        extraArgs = nil
    end
    return extraArgs
end
function api.addons:DisplayHats(hatTable)
   local wearingId = {}
   for i,v in pairs(game.Players:GetCharacterAppearanceInfoAsync(game.Players.LocalPlayer.UserId).assets) do 
        if v.id then 
            table.insert(wearingId,v.id)
        end
   end
   local newHatTable = {}
   if typeof(hatTable) == "string" then 
        local splitString = string.split(hatTable,"/")
        for i,v in pairs(splitString) do 
            if i > 1 then 
                if splitString[i-1] == "catalog" and tonumber(v) then 
                    table.insert(newHatTable,tonumber(v))
                end
            end
        end
        hatTable = newHatTable
   end
   local missingHats = {table.unpack(hatTable)}
   for index,hatId in pairs(hatTable) do    
        for _,assetId in pairs(wearingId) do 
            print("trying to match")
            if hatId == assetId then 
                table.remove(hatTable,table.find(hatTable,hatId))
            end
        end
   end
   if #hatTable > 0 then
    local GuiService = game:GetService("GuiService")
        local humanoidDescription = Instance.new("HumanoidDescription")
        humanoidDescription.HatAccessory = table.concat(hatTable,",")
        GuiService:InspectPlayerFromHumanoidDescription(humanoidDescription, "To get the script to work, you need these hats on your")
   end
end
api.console = loadstring(game:HttpGet("https://raw.githubusercontent.com/SaijiKung/Mexuit/main/Console%20Lib",true))();
--[[DOCUMENTATIOn
local UI = lib.new("Console Library")
local Page = UI.Page("Hi")
local Page2 = UI.Page("Hello")
Page.toggle("autofarm",true,print)
Page.call("Hello",function()
   print("called")
end)
Page2.str("some_str","ayo",function(str)
   print("some str changed to "..str)
end)
Page2.int("some_int",0,100,50,function(int)
   print("some int changed to "..int)
end)
Page2.list("some_list",{"Gamers","Bobux"},"Gamers",function(list)
   print("some list changed to "..list)
end)

Page.show()
]]
api.files = function(filePath)
    if isfolder(filePath) then 
    else makefolder(filePath) end
    local oldTable = listfiles(filePath)
    local originalTable = {}
    for i,v in pairs(oldTable) do 
        if string.find(v,".") then
            local index = string.split(v,[[\]])
             originalTable[string.gsub(index[#index],".lua","")] = readfile(v)
        end
    end
    for i,v in pairs(originalTable) do 
        if string.find(v,".") then
            print("from original table",i,v)
        end
    end
    local fileList = setmetatable({},{
        __newindex = function(self,index,value)
            print(self,index,value)
            print("trying to find",filePath..[[/]]..index..".lua")
             writefile(filePath..[[/]]..index..".lua",tostring(value))
           
            originalTable[index] = value
        end,
        __index = function(self,index)
            print("hi you mentioned index",index,originalTable[index])
            return originalTable[index]
        end
    })

    return fileList 
end
function api:DecodeJSON(jsonString)
    local HttpService = game:GetService("HttpService")
    local data = HttpService:JSONDecode(jsonString)
    return data
end
function api:EncodeJSON(dictionary)
    local HttpService = game:GetService("HttpService")
    local json = HttpService:JSONEncode(dictionary)
    return json
end
return api 