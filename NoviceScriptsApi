local api = {}

---Remotes

api.Remotes = {}
function api.Remotes.OnFire(callback) --Sends obj,args
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        local succ,err = pcall(callback,Self,{...})
        if err then 
            error(err)
        end
       return oldinvoke(self, ...)
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        local succ,err = pcall(callback,Self,{...})
        if err then 
            error(err)
        end
       return oldfire(self, ...)
    end)
end
function api.Remotes.RemoteOnFire(callback,remote) -- Sends args,caller
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        if Self == remote then 
             local succ,err = pcall(callback,Self,{...})
             if err then 
                error(err)
            end
        end
       return oldinvoke(self, ...)
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        if Self == remote then 
            local succ,err = pcall(callback,Self,{...})
            if err then 
                error(err)
            end
       end
       return oldfire(self, ...)
    end)

end
function api.Remotes:NullifyRemote(callback,remote,returnObject)
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        if Self == remote then 
             local succ,err = pcall(callback,Self,{...})
             if err then 
                error(err)
            end
        end
       return returnObject
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        if Self == remote then 
            local succ,err = pcall(callback,Self,{...})
            if err then 
                error(err)
            end
       end
       return returnObject
    end)
end

--Http spy
api.HttpRequests = {}
function api.HttpRequests.OnRequest(callback) -- Sends url, path
    local lol
    lol = hookfunc(game:HttpGet(function(path, url, ...)
        local succ,err = pcall(callback,tostring(url),path)
        if err then 
            error(err)
        end

        return lol(path, url, ...)
    end))
end
function api.HttpRequests:Nullify(otherChecks,returnObject)
    local lol
    lol = hookfunc(game:HttpGet(function(path, url, ...)
        local succ,err = pcall(callback,tostring(url),path)
        if err then 
            error(err)
        end
        return lol(path, url, ...)
    end))
end
--Index spy
api.Index = {}
--[[Index info is written like this 
Objects can be nil if you want it to be in general rather than on a specific object

IndexInfo={
    ["WalkSpeed"] = game.Players.LocalPlayer.Character --This path is an object
}
]]
function api.Index.OnIndex(callback,IndexInfo) -- Sends Object,Key (such as "WalkSpeed")
    local OldIndex = nil
    OldIndex = hookmetamethod(game, "__index", function(Self, Key)
        if not checkcaller() then
            local hasKey = false 
            for i,v in pairs(IndexInfo) do 
                if Key == i then
                    if v == nil then 
                        local err,succ = pcall(callback,Self,Key)
                        if err then 
                            error(err)
                        end
                    elseif v == Self then 
                        local err,succ = pcall(callback,Self,Key)
                        if err then 
                            error(err)
                        end
                    end
                end
            end
        end
        return OldIndex(Self, Key)
    end)
end

function api.Index.OnAllIndex(callback) --Sends Object,Key
    local OldIndex = nil
    OldIndex = hookmetamethod(game, "__index", function(Self, Key)
        if not checkcaller() then
            local err,succ = pcall(callback,Self,Key)
            if err then 
                error(err)
            end
        end
        return OldIndex(Self, Key)
    end)
end

--Namecall spy
api.Namecall = {}
--[[otherChecks format:
function(Method,Args)
    if Args[1] == game.Players.LocalPlayer then --Put your custom arguments here
        return true
    end
    return false 
end
]]
function api.Namecall:Nullify(index,returnObject,otherChecks) --index can be "Kick", otherchecks is not mandatory, sends the namecallmethod to otherChecks
    local OldNameCall = nil

    OldNameCall = hookmetamethod(game, "__namecall", function(Self, ...)    
                local Args = {...}
                local NamecallMethod = getnamecallmethod()
            
                if not checkcaller() and NamecallMethod == index then
                    if otherChecks == nil then 
                        return returnObject
                    elseif otherChecks(NamecallMethod,Args) then 
                        return returnObject
                    end
                end
    
        return OldNameCall(Self, ...)
    end)
end

function api.Namecall.OnNamecall(callback) --Sends the method, args ,self (ussualy game)
    local OldNameCall = nil

    OldNameCall = hookmetamethod(game, "__namecall", function(Self, ...)
        local Args = {...}
        local NamecallMethod = getnamecallmethod()
    
        if not checkcaller()  then
            
           local err,suc = pcall(callback,NamecallMethod,Args,Self)
            if err then 
                error(err)
            end
        end
    
        return OldNameCall(Self, ...)
    end)
end 

--Script api 
api.Script = function(Object)
    local lib = {}

    if Object:IsA("LocalScript") or Object:IsA("ModuleScript") then 
    else 
        return nil 
    end

    lib.Args = nil 
    if Object:IsA("ModuleScript") then  
        lib.Args = require(Object)
    else
        lib.Args = getsenv(Object)
    end


    function difference(a, b)
        local diff = {}
        for i,v in pairs(a) do
            if b[i] == v then 
            else 
                diff[tostring(i)] = v
            end
        end 
        return diff
    end
    --NewArgs arguments cna be like this 
    --[[
        {
            ["1"] = true,
            ["test"] = false,
        }
    ]]
    function lib:EditArgs(NewArgs)
        local diff = difference(NewArgs,lib.Args)
        for i,v in pairs(diff) do 
            lib.Args[i] = v
        end
    end
    function lib:Hook(func,callback)
        local oldFunc
        print("hook function args",func,callback)
            print("hook function types",typeof(func),typeof(callback))
        oldFunc = hookfunction(func,function(...)
            if not checkcaller() then 
                local args = {...}
                local suc,err = pcall(callback,Self,...)
                if err then 
                    error(err)
                end
            end
            return oldFunc(...)
        end)
    end
    function lib:Nullify(func,returnObject,otherChecks)
        local oldFunc
        oldFunc = hookfunction(func,function(...)
            if not checkcaller() then
                local Args = {...}
                if otherChecks == nil then 
                    return returnObject
                elseif otherChecks(func,Args) then 
                    return returnObject
                end
            end
            return oldFunc(...)
        end)
    end
    
    function lib:CopyValues()
        setclipboard(table.concat(lib.Args))
    end
    return lib
end

api.reg = {}
function api.reg:FilterType(infoType,callback) -- Sends a table of info, such as info.name; info.func. Also sends the value
    local reg = getreg()
    for i,v in pairs(reg) do 
        if infoType == nil then 
            callback(debug.getinfo(v),v)
        else 
            if type(v) == infoType then 
                callback(debug.getinfo(v),v)
            end
        end
    end
end
function api.reg:FilterName(infoName,callback) -- Sends a table of info, such as info.name; info.func. Also sends the value
    local reg = getreg()
    for i,v in pairs(reg) do 
        local info = debug.getinfo(v)
        if info then
            if info.name == infoName then 
                callback(debug.getinfo(v),v)
            end
        end
    end
end

api.gc = {}

function api.gc:FilterFunctions(constantTable,callback)
    for i,v in pairs(getgc()) do
        if type(v) == "function" and islclosure(v) and not checkcaller(v) then
            local consts = getconstants(v)
            if table.find(consts, "") and table.find(consts, "Filtered") and table.find(consts, "Clan") then
                return v
            end
        end
    end
end
function api.gc:FilterConstants(infoType,constantTable,callback)
    for i,v in pairs(getgc()) do
        if type(v) == infoType and islclosure(v) and not checkcaller(v) then
            local consts = getconstants(v)
            if table.find(consts, "") and table.find(consts, "Filtered") and table.find(consts, "Clan") then
                return v
            end
        end
    end
end
api.functions = {}
function api.functions:Nullify(func,returnObject,otherChecks)
    local oldFunc
    oldFunc = hookfunction(func,function(...)
        if not checkcaller() then
            local Args = {...}
            if otherChecks == nil then 
                return returnObject
            elseif otherChecks(func,Args) then 
                return returnObject
            end
        end
        return oldFunc(...)
    end)
end

api.console = loadstring(game:HttpGet("https://raw.githubusercontent.com/SaijiKung/Mexuit/main/Console%20Lib",true))();
--[[DOCUMENTATIOn
local UI = lib.new("Console Library")
local Page = UI.Page("Hi")
local Page2 = UI.Page("Hello")
Page.toggle("autofarm",true,print)
Page.call("Hello",function()
   print("called")
end)
Page2.str("some_str","ayo",function(str)
   print("some str changed to "..str)
end)
Page2.int("some_int",0,100,50,function(int)
   print("some int changed to "..int)
end)
Page2.list("some_list",{"Gamers","Bobux"},"Gamers",function(list)
   print("some list changed to "..list)
end)

Page.show()
]]
api.files = function(filePath)
    if isfolder(filePath) then 
    else makefolder(filePath) end
    local oldTable = listfiles(filePath)
    local originalTable = {}
    for i,v in pairs(oldTable) do 
        if string.find(v,".") then
            local index = string.split(v,[[\]])
             originalTable[string.gsub(index[#index],".lua","")] = readfile(v)
        end
    end
    for i,v in pairs(originalTable) do 
        if string.find(v,".") then
            print("from original table",i,v)
        end
    end
    local fileList = setmetatable({},{
        __newindex = function(self,index,value)
            print(self,index,value)
            print("trying to find",filePath..[[/]]..index..".lua")
             writefile(filePath..[[/]]..index..".lua",tostring(value))
           
            originalTable[index] = value
        end,
        __index = function(self,index)
            print("hi you mentioned index",index,originalTable[index])
            return originalTable[index]
        end
    })

    return fileList 
end
function api:DecodeJSON(jsonString)
    local HttpService = game:GetService("HttpService")
    local data = HttpService:JSONDecode(jsonString)
    return data
end
function api:EncodeJSON(dictionary)
    local HttpService = game:GetService("HttpService")
    local json = HttpService:JSONEncode(dictionary)
    return json
end
return api 