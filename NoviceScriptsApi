local api = {}

---Remotes

api.Remotes = {}
function api.Remotes.OnFire(callback) --Sends obj,args
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        local succ,err = pcall(callback,Self,{...})
        if err then 
            error(err)
        end
       return oldinvoke(self, ...)
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        local succ,err = pcall(callback,Self,{...})
        if err then 
            error(err)
        end
       return oldfire(self, ...)
    end)
end
function api.Remotes.RemoteOnFire(callback,remote) -- Sends args,caller
    local oldinvoke, oldfire
    oldinvoke, oldfire = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(Self, ...)
        if Self == remote then 
             local succ,err = pcall(callback,Self,{...})
             if err then 
                error(err)
            end
        end
       return oldinvoke(self, ...)
    end), hookfunction(Instance.new("RemoteEvent").FireServer, function(Self, ...) 
        if Self == remote then 
            local succ,err = pcall(callback,Self,{...})
            if err then 
                error(err)
            end
       end
       return oldfire(self, ...)
    end)

end

--Http spy
api.HttpRequests = {}
function api.HttpRequests.OnRequest(callback) -- Sends url, path
    local lol
    lol = hookfunc(game:HttpGet(function(path, url, ...)
        local succ,err = pcall(callback,tostring(url),path)
        if err then 
            error(err)
        end

        return lol(path, url, ...)
    end))
end
function api.HttpRequests:Nullify(otherChecks,returnObject)
    local lol
    lol = hookfunc(game:HttpGet(function(path, url, ...)
        local succ,err = pcall(callback,tostring(url),path)
        if err then 
            error(err)
        end
        return lol(path, url, ...)
    end))
end
--Index spy
api.Index = {}
--[[Index info is written like this 
Objects can be nil if you want it to be in general rather than on a specific object

IndexInfo={
    ["WalkSpeed"] = game.Players.LocalPlayer.Character --This path is an object
}
]]
function api.Index.OnIndex(callback,IndexInfo) -- Sends Object,Key (such as "WalkSpeed")
    local OldIndex = nil
    OldIndex = hookmetamethod(game, "__index", function(Self, Key)
        if not checkcaller() then
            local hasKey = false 
            for i,v in pairs(IndexInfo) do 
                if Key == i then
                    if v == nil then 
                        local err,succ = pcall(callback,Self,Key)
                        if err then 
                            error(err)
                        end
                    elseif v == Self then 
                        local err,succ = pcall(callback,Self,Key)
                        if err then 
                            error(err)
                        end
                    end
                end
            end
        end
        return OldIndex(Self, Key)
    end)
end

function api.Index.OnAllIndex(callback) --Sends Object,Key
    local OldIndex = nil
    OldIndex = hookmetamethod(game, "__index", function(Self, Key)
        if not checkcaller() then
            local err,succ = pcall(callback,Self,Key)
            if err then 
                error(err)
            end
        end
        return OldIndex(Self, Key)
    end)
end

--Namecall spy
api.Namecall = {}
--[[otherChecks format:
function(Method,Args)
    if Args[1] == game.Players.LocalPlayer then --Put your custom arguments here
        return true
    end
    return false 
end
]]
function api.Namecall:Nullify(index,returnObject,otherChecks) --index can be "Kick", otherchecks is not mandatory, sends the namecallmethod to otherChecks
    local OldNameCall = nil

    OldNameCall = hookmetamethod(game, "__namecall", function(Self, ...)    
                local Args = {...}
                local NamecallMethod = getnamecallmethod()
            
                if not checkcaller() and NamecallMethod == index then
                    if otherChecks == nil then 
                        return returnObject
                    elseif otherChecks(NamecallMethod,Args) then 
                        return returnObject
                    end
                end
    
        return OldNameCall(Self, ...)
    end)
end

function api.Namecall.OnNamecall(callback) --Sends the method, args ,self (ussualy game)
    local OldNameCall = nil

    OldNameCall = hookmetamethod(game, "__namecall", function(Self, ...)
        local Args = {...}
        local NamecallMethod = getnamecallmethod()
    
        if not checkcaller()  then
            
           local err,suc = pcall(callback,NamecallMethod,Args,Self)
            if err then 
                error(err)
            end
        end
    
        return OldNameCall(Self, ...)
    end)
end 

--Script api 
api.Script = function(Object)
    local lib = {}

    if Object:IsA("LocalScript") or Object:IsA("ModuleScript") then 
    else 
        return nil 
    end

    lib.Args = nil 
    if Object:IsA("ModuleScript") then  
        lib.Args = require(Object)
    else
        lib.Args = getsenv(Object)
    end


    function difference(a, b)
        local diff = {}
        for i,v in pairs(a) do
            if b[i] == v then 
            else 
                diff[tostring(i)] = v
            end
        end 
        return diff
    end
    --NewArgs arguments cna be like this 
    --[[
        {
            ["1"] = true,
            ["test"] = false,
        }
    ]]
    function lib:EditArgs(NewArgs)
        local diff = difference(NewArgs,lib.Args)
        for i,v in pairs(diff) do 
            lib.Args[i] = v
        end
    end
    function lib:Hook(func,callback)
        local oldFunc
        print("hook function args",func,callback)
            print("hook function types",typeof(func),typeof(callback))
        oldFunc = hookfunction(func,function(...)
            if not checkcaller() then 
                local args = {...}
                local suc,err = pcall(callback,Self,...)
                if err then 
                    error(err)
                end
            end
            return oldFunc(...)
        end)
    end
    function lib:Nullify(func,returnObject,otherChecks)
        local oldFunc
        oldFunc = hookfunction(func,function(...)
            if not checkcaller() then
                local Args = {...}
                if otherChecks == nil then 
                    return returnObject
                elseif otherChecks(func,Args) then 
                    return returnObject
                end
            end
            return oldFunc(...)
        end)
    end
    
    function lib:CopyValues()
        setclipboard(table.concat(lib.Args))
    end
    return lib
end

api.console = loadstring(game:HttpGet("https://raw.githubusercontent.com/SaijiKung/Mexuit/main/Console%20Lib",true))();
--[[DOCUMENTATIOn
local UI = lib.new("Console Library")
local Page = UI.Page("Hi")
local Page2 = UI.Page("Hello")
Page.toggle("autofarm",true,print)
Page.call("Hello",function()
   print("called")
end)
Page2.str("some_str","ayo",function(str)
   print("some str changed to "..str)
end)
Page2.int("some_int",0,100,50,function(int)
   print("some int changed to "..int)
end)
Page2.list("some_list",{"Gamers","Bobux"},"Gamers",function(list)
   print("some list changed to "..list)
end)

Page.show()
]]
api.files = function(filePath)
    if isfolder(filePath) then 
    else makefolder(filePath) end
    local oldTable = listfiles(filePath)
    local originalTable = {}
    for i,v in pairs(oldTable) do 
        if string.find(v,".") then
             originalTable[i] = readfile(v)
        end
    end
    local fileList = setmetatable({},{
        __newindex = function(self,index,value)
            print(self,index,value)
            writefile(filePath.."/"..index..".lua",tostring(value))
            originalTable[index] = value
        end
       
    })

    return fileList 
end

return api 